composition api
===============
write group logic/function together in a setup() function
easily create usuable code and can import from other component
setup() function come before lifecycle hooks and others

setup() function
================
inside setup() function, you can define whatever you want and
must return it as an object to use in template
let name = 'y2k',age = 20;
return {name : name , age : age }   / shorthand = return {name , age }
but name and age in setup() are not reactive value by default like in  data() function

template ref
============
this.$ref.name in data() <p ref = "name">name </p>

in setup()
==========
import {ref} from 'vue'
//null is value of ref
//const p means ref is const but value can be chanage/ reactive
const  p = ref(null)

<p ref="p">blah blah</p>

to access <p> tag p / p.value
to add classlist / can use normal js class
p.value.classList.add('actives')

must return p before use 
return p ma (p / p.value) ko use lo ya

using ref for reactivity
========================
  //yyk is value of ref
    //(const name) means ref is const but value can be chanage/ reactive
    const name = ref("yyk");
    const age = ref(20);

    const handleClick = () => {
      // to access ref.value in setup(), use refName.value
      // but to need to use name.value  in template, it auto output {{ value of ref in template }}
      //can use v-model="ref" for input reactivity
      name.value = "asdf";
      age.value = 22;
    };
    return { name, age, handleClick };
  },
};
<input type="text" v-model="name" />
 <p ref="p">name : {{ name }} , age : {{ age }}</p>

ref vs reactive
=================
// no need to use ninjaTwo.value.name  like in ref/ just use ninjaTwo.name and can auto acces value directly
//reactive cannot use with primitive data type like in ref
    const ninjaTwo = reactive("mario");  => mario is a primitive value in reactive and reactive cannot update mario while ref.value.name can 

ref also work better with external composition function
they retain their reactivity 

 //using computed
    const filteringName = computed(() => {
      return names.value.filter((name) => {
        return name.includes(search.value);
      });
    });

watch(watch-parameter,callback func) and watchEffect(callback func) 
===================================================================
 const search = ref("");
    const names = ref(["mario", "uno", "john", "doe", "coopa", "y2k"]);
    //watch value everytimes they change
    //need to pass parameter to watch
    //search is a watched parameter and watch func ran when value of search chaange
    watch(search, () => {
      console.log("watch func ran");
    });

    //ran initally first
    //no need to pass parameter to watch / it watch all the value which used inside its function
    //watch value change inside its function and watcheffect func ran when value of used inside its func changes
    //search is used in its function and it watch search initially first and run everytimes search change
    watchEffect(() => {
      console.log("watch effect func ran" + search.value);
    });

Props
=====
//same as options api, to use props in setup() need to pass props parameter and
//access props.propsName
  props: ["person"],
  setup(props) {
    let name = props.person.name;
    let age = props.person.age;
    let gender = props.person.gender;
    console.log(props);
    return { name, age, gender };
  },